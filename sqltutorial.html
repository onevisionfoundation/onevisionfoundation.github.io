<!DOCTYPE html>
<html>
    
    <header>
        <title>OV Oracle SQL</title>   
        <link rel="stylesheet" href="w3.css">
        <link rel="stylesheet" href="sqltutorial.css">
        
       
    </header>   
    <body style="padding-top: 0px">
        
   <div class="w3-sidebar w3-bar-block w3-teal" style="width:16%"> 
       <h2>Menu</h2>
      <ol type="A">
            <li><a href="#deb" class="w3-bar-item w3-button">Déblocage du conte HR</a></li>
             
          <li> <a href="#lan" class="w3-button">Langage d'intérrogation<i class="fa fa-caret-down"></i></a></li>
          <ol>
              <li><a href="#syn" class="w3-bar-item w3-button">Syntaxe (SELECT)</a></li>
              <li><a href="#pse" class="w3-bar-item w3-button">Pseudo-table DUAL</a></li>
              <li> <a href="#pro" class="w3-bar-item w3-button">Projection (éléments du SELECT)</a></li>
              <li><a href="#res" class="w3-bar-item w3-button">Restriction (WHERE)</a></li>
              <li><a href="#ope" class="w3-bar-item w3-button">Opérateurs INTEGRES</a></li>
              <li> <a href="#fon" class="w3-bar-item w3-button">Les fonction</a></li>
              <li><a href="#con" class="w3-bar-item w3-button">Les conversion</a></li>
              <li><a href="#gro" class="w3-bar-item w3-button">Les groupements</a></li>
              <li><a href="#opa" class="w3-bar-item w3-button">Les opérateur assemblistes</a></li>
              <li><a href="#joi" class="w3-bar-item w3-button">Les jointures</a></li>
          </ol>
          
        <li><a href="exercicesql.html" class="w3-bar-item w3-button">Exercices et solutions</a></li>
      </ol>
    </div>

        <div style="margin-left:16%;margin-top: -10px;">
            <div class="w3-panel">
              <h1  style="text-align: center; color: teal;"><strong>Bienvenue dans Oracle SQL Tutoriel</strong></h1>
                <dl>
                    <dt><h2  style="padding-left: 1.2em;">Introduction</h2></dt>
                    <dd>SQL (Structured Query Language), est un langage destiné à la gestion des bases de données relationnelles. Dans ces tutoriels, nous allons utiliser Oracle comme Système de Gestion de Base de Données (SGBD) dévéloppé par Oracle Corporation. Pour commencer, il faut savoir qu’Oracle comporte plusieurs types d’objets. Les plus utilisés sont les <b>Tables, les Vues, les Triggers (ou Déclencheurs) </b>, les Fonctions, les Procédures et les Packages. Bien sûr il existe d’autres composants dont on va parler dans un autre tutorial.</dd>
                     </dl>
                     <dl>
                        <dt><h2  style="padding-left: 1.2em;">Oracle corporation</h2></dt>
                        <dd>Societé américaine située en Californie, développe et commercialise un SGBD et un ensemble de produits de développement. Oracle a des filiales dans un grand nombre de pays. La filiale française (Oacle France) a été créée en 1986, elle est composée de cinq départements (marketing, comlmercial,avant-vente,conseil et formation).<br><br><br>
                    </dl>
            </div>
        
        
        
        <div class="w3-card-4" style="margin-top: -1em;">

            <header class="w3-container w3-blue">
              <h1 id="deb">A. Déblocage du conte HR</h1>
            </header>

            <div class="w3-container w3-sand" style="border-left: 10px solid #558dd1;">
                <dl>
                    <dt><h3>Les etapes à suivre...</h3></dt>
                    <dd>Après l'intallation d'oracle express 11g, il existe un compte utilisateur HR déja mis en place par la communauté oracle. Ce compte permet aux apprenants de gagner du temps dans leurs apprentissages car on y trouve des tableaux déja rempli sur lesquels nous pouvons exécuter de requètes SQL. Mais par défaut, ce compte est bloquer, ce qui nous donne pas accès aux tableaux.<br />
                        Dans cette partie, nous allons débloquer le compte HR et lui donner un mot de passe unique nous permettant d'y accedé. Il existe plusieurs methodes pour débloquer le compte HR, dans notre cas, nous allons le débloquer et changer le mot de passe en une seule ligne dans <strong>l'invité de commande SQL</strong>.<br />
                        Executer les commandes suivantes:<br />

                        <ol class="olhr">
                            <li>Connecter vous dabord à votre compte system:<br />
                                <code>connect system/[mot_de_pass]</code><br />
                                <i>[mot_de_pass] est le mot de pass fourni lors de l'instalation d'oracle 11g (selon votre version).</i>

                            </li>
                            <li>Debloquer maintenant le compte HR<br />
                                <em><code>alter user hr account unlock identified by [mot de pass]</code></em><br />
                                <i>[mot_de_pass] est le mot de pass que vous allez utiliser pour vous connecter au compte HR (à ne pas oublié).</i><br />
                                Vous pouvez vérifier en executant:  <ode>select * from employees</ode>
                            </li>

                        </ol>
                    </dd>
                </dl>
            </div>

            <footer class="w3-container w3-blue">
              <h5>Note: Pour vous exercer sur les tableaux du compte HR, vous avez à votre disposition une liste d'exercice pouvant vous aider dans la partie exercice du menu.</h5>
            </footer>

        </div>
            
            
           <!--
            creation de
        -->
            
            <div class="w3-card-4" style="margin-top: 1em;">

            <header class="w3-container w3-green">
              <h1 id="lan">B. Langage d'intérrogation</h1>
            </header>

            <div class="w3-container w3-sand" style="border-left: 10px solid #69bf3e;">
                
                
            <dl style="padding-left: 2px;">
            <dt><h3>L'aspect le plus connu du langage SQL</h3></dt>
            <dd>Cette partie traite de l’aspect le plus connu du langage SQL à savoir l’extraction des données
                par requêtes (nom données aux instructions SELECT). Une requête permet de rechercher des
                données dans une ou plusieurs tables ou vues à partir de critères simples ou complexes. Les
                instructions SELECT peuvent être exécutées dans l’interface SQL*Plus.<br /><br />
                
                <b id="syn"><u>1. Syntaxe (SELECT)</u></b><br />
                Pour pouvoir extraire des enregistrements d’une table, il faut avoir reçu le privilège SELECT
                sur la table.<br /> Le privilège SELECT ANY TABLE permet d’extraire des données dans toute table
                de tout schéma.<br />
                La syntaxe SQL simplifiée de l’instruction SELECT est la suivante :<br /><br />
                SELECT [ { DISTINCT | UNIQUE } | ALL ] listeColonnes<br />
                FROM nomTable1 [, nomTable2]…<br />
                [ WHERE condition ]<br />
                [ clauseHiérarchique ]<br />
                [ clauseRegroupement ]<br />
                [ HAVING condition ]<br />
                [ { UNION | UNION ALL | INTERSECT | MINUS } ( sousRequête )]<br />
                [ clauseOrdonnancement ] ;<br /><br />
                dans les lignes qui suivent, nous détaillerons  chaque option à l’aide d’exemples<br /><br />
                <b id="pse"><u>2. Pseudo-table DUAL</u></b><br />
                La table DUAL est une table utilisable par tous (en lecture seulement) et qui appartient à l’utilisateur SYS. Le paradoxe de DUAL réside dans le fait qu’elle est couramment sollicitée, mais
                les interrogations ne portent jamais sur sa seule colonne (DUMMY définie en VARCHAR2 et
                contenant un seul enregistrement avec la valeur « X »). En conséquence, DUAL est qualifiée
                de pseudo-table (c’est la seule qui soit ainsi composée).<br />
                <code>SELECT 'Il reste encore beaucoup de pages?' FROM DUAL;</code> /* cette phrase ne reside dans aucunetable*/<br /><br />
                
                <b id="pro"><u>3. Projection (éléments du SELECT)</u></b><br />
                Étudions la partie de l’instruction SELECT qui permet de programmer l’opérateur de projection (en surligné dans la syntaxe suivante) :<br /><br />
                SELECT <em>[ { DISTINCT | UNIQUE } | ALL ] listeColonnes</em><br />
                 FROM nomTable [ aliasTable]<br />
                [ clauseOrdonnancement ] ;<br />
                ● DISTINCT et UNIQUE jouent le même rôle : ne pas prendre en compte les duplicatas.<br />
                ● ALL : prend en compte les duplicatas (option par défaut).<br />
                ● ListeColonnes : { * | expression1 [[AS] alias1 ] [, expression2
                [[AS] alias2 ]…} .<br />
                ● * : extrait toutes les colonnes de la table.<br />
                ● expression : nom de colonne, fonction, constante ou calcul.<br />
                ● alias : renomme l’expression (nom valable pendant la durée de la requête).<br />
                ● FROM : désigne la table (qui porte un alias ou non) à interroger.<br />
                ● clauseOrdonnancement : tri sur une ou plusieurs colonnes ou expressions.<br />
                
                <ol type="a">
                    <li>Extraction de toutes les colonnes:<br />
                        L’extraction de toutes les colonnes d’une table requiert l’utilisation du symbole « * ».</li>
                    <code>SELECT * FROM employees;</code>
                    <li>Extraction de certaines colonnes<br />
                        La liste des colonnes à extraire se trouve dans la clause SELECT.</li>
                     <code>SELECT first_name, last_name FROM employees;</code><br />
                    <li>Alias<br />
                        Les alias permettent de renommer des colonnes à l’affichage ou des tables dans la requête. Les
                        alias de colonnes sont utiles pour les calculs</li>
                     <code>SELECT first_name AS Prenom, last_name AS Nom, salary salaire FROM employees;</code><br />
                    <li>Duplicatas<br />
                        Les directives DISTINCT ou UNIQUE éliminent les éventuels duplicatas. Pour la deuxième
                        requête, les écritures DISTINCT compa, UNIQUE(compa)  et UNIQUE compa sont équivalentes. La notation entre parenthèses est nécessaire lorsque l’on désire éliminer des duplicatas
                        par paires, triplets, etc<br />
                        <code> SELECT DISTINCT(compa) FROM Pilote;</code>
                        </li>
                    <li>Ordonnancement<br />
                        Pour trier le résultat d’une requête, il faut spécifier la clause d’ordonnancement par ORDER BY
                        de la manière suivante :<br /><br />
                    
                        ORDER [SIBLINGS] BY<br />
                        { expression1 | position1 | alias1 } [ASC | DESC] [ NULLS FIRST |
                        NULLS LAST ]<br />
                        [,{ expression2 | position2 | alias2} [ASC | DESC] [NULLS FIRST |
                        NULLS LAST]]…<br /><br />
                        ● SIBLINGS : relatif aux requêtes hiérarchiques, couplé au CONNECT BY.<br />
                        ● expression : nom de colonne, fonction, constante, calcul.<br />
                        ● position : entier qui désigne l’expression (au lieu de la nommer) dans son ordre d’apparition dans la clause SELECT.<br />
                        ● ASC ou DESC : tri ascendant ou descendant (par défaut ASC).<br />
                        ● NULLS FIRST ou NULLS LAST : position des valeurs nulles (au début ou à la fin du
                        résultat). <br />
                        NULLS LAST par défaut pour l’option ASC, NULLS FIRST par défaut pour
                        l’option DESC.<br /><br />
                        <code>SELECT last_name, first_name FROM employees ORDER BY last_name;</code><br />
                        <code>SELECT last_name,first_name FROM employees ORDER BY first_name ASC NULLS FIRST;</code>
                        </li>
                    <li>Concaténation<br>
                    L’opérateur de concaténation s’écrit avec deux barres verticales ( || ).<br> Il permet de concaténer
                    des expressions (colonnes, calculs, fonctions ou constantes). La colonne résultante est considérée comme une chaîne de caractères.<br>
                        L’exemple suivant présente un alias dans l’en-tête de colonne ("Embauche") qui met en forme
                        les résultats. La concaténation concerne deux colonnes et la constante « vole pour ».<br>
                        <code>SELECT last_name,
                            nom||' '||first_name AS "Embauche"
                            FROM employees;
                        </code>
                    
                    
                    </li>
                    <li>Pseudo-colonne ROWNUM<br>
                        La pseudo-colonne ROWNUM retourne un entier indiquant l’ordre séquentiel de chaque enregistrement extrait par la requête. Le premier possède implicitement une colonne ROWNUM évaluée
                        à 1, pour le deuxième elle l’est à 2, etc.<br>
                        <code>SELECT ROWNUM, brevet, nom
                        FROM Pilote;</code>
                    
                    
                    </li>
                 </ol>
                <b id="res"><u>4. Restriction (WHERE)</u></b><br />
                Les éléments de la clause WHERE d’une requête permettent de programmer l’opérateur de
                restriction. Cette clause limite la recherche aux enregistrements qui respectent une condition
                simple ou complexe. Cette section s’intéresse à la partie surlignée de l’instruction SELECT
                suivante :<br><br>
                
                SELECT [ { DISTINCT | UNIQUE } | ALL ] listeColonnes<br>
                FROM nomTable [aliasTable]<br>
                <em>[ WHERE condition ]</em> ;<br><br>
                ● condition : est composée de colonnes, d’expressions, de constantes liées deux à deux entre
                des opérateurs :<br>
                – de comparaisons (>, =,&#60;, &#60; > ) ;<br>
                – logiques (NOT, AND ou OR) ;<br>
                – intégrés (BETWEEN, IN, LIKE, IS NULL)<br><br>
                <code>
                SELECT salary AS "Prime"
                FROM employees WHERE salary=2000;
                </code><br>
                
                <b id="ope"><u>5. Opérateurs INTEGRES</u></b><br />
                Les opérateurs intégrés sont BETWEEN, IN, LIKE et IS NULL<br><br>
                <ol>
                    <li>BETWEEN limiteInf AND limiteSup :<br>
                        teste l’appartenance à un intervalle de valeurs<br>
                        <code>SELECT brevet, nom, nbHVol FROM Pilote WHERE nbHVol BETWEEN 399 AND 1000 ;</code>
                    </li>
                    <li>IN (listeValeurs) compare une expression
                        avec une liste de valeurs<br>
                        <code>SELECT brevet, nom, compa FROM Pilote
                            WHERE compa IN ('CAST', 'SING');</code>
                        
                    </li>
                    <li>
                    LIKE (expression) :<br>compare de manière
                    générique des chaînes de caractères à une
                    expression.<br>
                    Le symbole % remplace un ou plusieurs
                    caractères.<br>
                    Le symbole _ remplace un caractère.<br>
                    Ces symboles peuvent se combiner.<br>
                    Utilisez de préférence des colonnes VARCHAR ou
                    complétez si nécessaire par des blancs jusqu’à la
                    taille maximale pour des CHAR<br>
                        
                    </li>
                    <li>IS NULL :<br>compare une expression (colonne,
                    calcul, constante) à la valeur NULL.<br>
                    La négation s’écrit soit « expression IS NOT
                    NULL » soit « NOT (expression IS NULL) »
                        
                    </li>
                    </ol>
                
                <b id="fon"><u>6. LES FONCTIONS</u></b><br />
                Oracle propose un grand nombre de fonctions qui s’appliquent dans les clauses SELECT ou
                WHERE d’une requête. La syntaxe générale d’une fonction est la suivante :<br>
                <code>nomFonction(colonne1 | expression1 [,colonne2 | expression2 …])</code><br><br>
                <strong>• <u>Une fonction monoligne</u></strong> agit sur une ligne à la fois et ramène un résultat par ligne. On distingue quatre familles de fonctions monolignes : <strong>caractères, numériques, dates et conversions
                de types de données.</strong> Ces fonctions peuvent se combiner entre elles (exemple :
                MAX(COS(ABS(n))) désigne le maximum des cosinus de la valeur absolue de la colonne n).<br>
                <strong>• <u>Une fonction multiligne (fonction d’agrégat)</u></strong> agit sur un ensemble de lignes pour ramener un résultat (voir la section « Regroupements »).<br>
                
                <ol>
                    <li>Les fonction pour les caractères (Fonctions monolignes)<br>
                        La plupart des fonctions pour les caractères acceptent une chaîne de caractères en paramètre
                        de nature CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, ou NCLOB. Le tableau suivant
                        décrit les principales fonctions :
                        <table class="w3-table-all w3-hoverable">
                            <th>Fonction</th>
                            <th>Objectif</th>
                            <tr>
                                <td>ASCII(c)</td>
                                <td>Retourne le caractère
                                    ASCII équivalent.</td>
                            </tr>
                            
                            
                            <tr>
                                <td>CONCAT(c1,c2)</td>
                                <td>Concatène (équivalent à
                                    ||), est opérationnel pour
                                    les LOB</td>
                            </tr>
                            <tr>
                                <td>INITCAP(c)</td>
                                <td>Première lettre de chaque
mot en majuscule</td>
                            </tr>
                            <tr>
                                <td>INSTR(c1, c2 [,p
[,o]])</td>
                                <td>Premier indice d’une souschaîne c2 dans une chaîne
c1.
Exemple : indice du 2e 'Air'
après le 9e caractère.</td>
                            </tr>
                            <tr>
                                <td>LOWER(c)</td>
                                <td>Tout en minuscules</td>
                            </tr>
                            <tr>
                                <td>LENGTH(c)</td>
                                <td>Longueur de la chaîne</td>
                            </tr>
                            <tr>
                                <td>LPAD(c1,n,c2)</td>
                                <td>Insertion à gauche de c2
dans c1 sur n caractères</td>
                            </tr>
                            <tr>
                                <td>LTRIM(c1,c2)</td>
                                <td>Enlève c2 à c1 en
examinant la gauche de
c1.</td>
                            </tr>
                            <tr>
                                <td>REPLACE(c1,c2,
c3)</td>
                                <td>Recherche les c2
présentes dans c1 et les
remplace par c3</td>
                            </tr>
                            <tr>
                                <td>RPAD(c1,n,c2)</td>
                                <td>Insertion à droite de c2
dans c1 sur n caractères.</td>
                            </tr>
                            <tr>
                                <td>RTRIM(c1,c2)</td>
                                <td>Enlève c2 à c1 en
examinant la droite de c1</td>
                            </tr>
                            <tr>
                                <td>SOUNDEX(c)</td>
                                <td>Extrait la phonétique d’une
expression (in english
only !)</td>
                            </tr>
                            <tr>
                                <td>SUBSTR(c,n,[t])</td>
                                <td>Extraction de la souschaîne c commençant à la
position n sur t caractères</td>
                            </tr>
                            <tr>
                                <td>TRANSLATE('c1',
'de', 'vers')</td>
                                <td>Transforme chaque
caractère de c1 existant
dans de ayant un
correspondant dans vers</td>
                            </tr>
                             <tr>
                                <td>TRIM(c1 FROM c2)</td>
                                <td>Enlève les caractères c1 à
la chaîne c2 (options LEADING et TRAILING pour
préciser le sens du
découpage).</td>
                            </tr>
                             <tr>
                                <td>UPPER(c)</td>
                                <td>Tout en majuscules</td>
                            </tr>
                            
                        
                        </table>
                    <br>
                    </li>
                    <li>Quelques fonctions numeriques (Fonctions monoligne):<br>
                        La plupart des fonctions numériques acceptent en paramètre une ou plusieurs expressions de
type NUMBER.<br>    
                    <table class="w3-table-all w3-hoverable">
                            <th>Fonction</th>
                            <th>Objectif</th>
                            <tr>
                                <td>ABS(n)</td>
                                <td>Valeur absolue de n</td>
                            </tr>
                        <tr>
                                <td>FLOOR(n)</td>
                                <td>Plus grand entier ≤ à n.</td>
                            </tr>
                        <tr>
                                <td>MOD(m,n)</td>
                                <td>Division entière de m par n</td>
                            </tr>
                        <tr>
                                <td>POWER(m,n)</td>
                                <td>m puissance n.</td>
                            </tr>
                        <tr>
                                <td>SQRT(n)</td>
                                <td>Racine carrée de n</td>
                            </tr>
                        <tr>
                                <td>COS(n)</td>
                                <td>Cosinus de n exprimé en
radians de 0 à 2 pi
(conversion en degrés :
d*3.14159265359/180)</td>
                            </tr>
                    </table><br>
                    </li>
                    <li>Les fonctions de Date (Fonctions monoligne):<br>
                        Le tableau suivant décrit les principales fonctions pour les dates.
                    <table class="w3-table-all w3-hoverable">
                            <th>Fonction</th>
                            <th>Objectif</th>
                            <tr>
                                <td>ADD_MONTHS</td>
                                <td>Ajoute des mois à une date</td>
                            </tr>
                        <tr>
                                <td>CURRENT_DATE</td>
                                <td>Retourne la date courante (calendrier grégorien)
dans la session et le fuseau de la base</td>
                            </tr>
                        <tr>
                                <td>EXTRACT({YEAR | MONTH | DAY |
HOUR | MINUTE | SECOND} FROM
{d | i})</td>
                                <td>Extrait une partie donnée d’une date ou d’un
intervalle. elle retourne un nombre</td>
                            </tr>
                        <tr>
                                <td>LAST_DAY(d)</td>
                                <td>Retourne le dernier jour du mois</td>
                            </tr>
                        <tr>
                                <td>MONTHS_BETWEEN(d1,d2)</td>
                                <td>Retourne le nombre de mois entre deux dates (d1
et d2 avec d1>d2).Retourne un nombre.</td>
                            </tr>
                        <tr>
                                <td>NEW_TIME (d,z1,z2)</td>
                                <td>Retourne la date d exprimée en zone z1 dans la
zone z2</td>
                            </tr>
                        <tr>
                                <td>NEXT_DAY(d,jour)</td>
                                <td>Retourne la date du prochain jour ouvrable
(exemple jour ‘LUNDI’) à partir de d</td>
                            </tr>
                        <tr>
                                <td>ROUND(d,format)</td>
                                <td>Arrondit une date d selon un format (exemple :
‘YEAR’)</td>
                            </tr>
                        <tr>
                                <td>SYSDATE</td>
                                <td>Date courante (du système).</td>
                            </tr>
                        <tr>
                                <td>TRUNC(d,format)</td>
                                <td>Tronque une date d selon un format (exemple :
‘YEAR’).</td>
                            </tr>
                    </table>
                    </li>
                </ol>
                
                <b id="con"><u>7. es CONVERSIONS</u></b><br /><br />
               ** Implicite:<br>Il est possible d’affecter dans une expression ou dans une instruction SQL (INSERT,
UPDATE…), une donnée de type NUMBER (ou DATE) à une donnée de type VARCHAR2 (ou
CHAR). Il en va de même pour l’affectation d’une colonne VAR.<br><br>
                ** Explicite:<br />Une conversion est dite explicite quand on utilise une fonction à cet effet. Les fonctions de
conversion les plus connues sont TO_NUMBER, TO_CHAR et TO_DATE.<br>
                <b id="autref"><u>Autres fonctions</u></b><br /><br />
                
Il existent d’autres fonctions n’appartenant pas à la classification précédente : Exemple<br>
                DECODE(colonne,
cherche, resultat
[,cherche,resultat]…)<br>
Programme un case.<br>
Exemple:  <code>DECODE(grade, 1, 'Copilote',
2,' Instructeur') //affiche
‘Copilote’ si la colonne grade=1</code><br /><br />
                
                
                 <b id="gro"><u>8. LES GROUPEMENTS</u></b><br /><br />
                Cette section traite à la fois des regroupements de lignes (agrégats) et des fonctions de groupe
                (multiligne). Nous étudierons la partie surlignée de l’instruction SELECT suivante :<br /><br />
                SELECT [ { DISTINCT | UNIQUE } | ALL ] listeColonnes<br />
                FROM nomTable<br />
                [ WHERE condition ]<br />
               <em> [ clauseRegroupement ] ;<br />
                   [ HAVING condition ]
                </em><br /><br />
                ● listeColonnes : peut inclure des expressions (présentes dans la clause de regroupement) ou des fonctions de groupe.<br />
                ● clauseRegroupement : GROUP BY (expression1[,expression2]…) permet
                de regrouper des lignes selon la valeur des expressions (colonnes, fonction, constante,
                calcul).<br />
                ● HAVING condition : pour inclure ou exclure des lignes aux groupes (la condition ne
                peut faire intervenir que des expressions du GROUP BY)<br /><br>
                
                <u>Fonctions de groupe:</u><br>
                Nous étudions dans cette section les fonctions usuelles. D’autres sont proposées pour manipuler
des cubes (datawarehouse).
Le tableau suivant présente les principales fonctions. L’option DISTINCT évite les duplicatas
alors que ALL les prend en compte (par défaut). À l’exception de COUNT, toutes les fonctions
ignorent les valeurs NULL (il faudra utiliser NVL pour contrer cet effet).<br>
                 <table class="w3-table-all w3-hoverable">
                            <th>Fonction</th>
                            <th>Objectif</th>
                            <tr>
                                <td>AVG([DISTINCT | ALL] expr)</td>
                                <td>Moyenne de expr (nombre)</td>
                            </tr>
                     <tr>
                                <td>COUNT({* | [DISTINCT | ALL] expr})</td>
                                <td>Nombre de lignes (* toutes les lignes, expr pour les
colonnes non nulles)</td>
                            </tr>
                     <tr>
                                <td>MAX([DISTINCT | ALL] expr)</td>
                                <td>Maximum de expr (nombre, date, chaîne).</td>
                            </tr>
                     <tr>
                                <td>MIN([DISTINCT | ALL] expr)</td>
                                <td>Minimum de expr (nombre, date, chaîne)</td>
                            </tr>
                     <tr>
                                <td>STDDEV([DISTINCT | ALL] expr)</td>
                                <td>Écart type de expr (nombre)</td>
                            </tr>
                     <tr>
                                <td>SUM([DISTINCT | ALL] expr)</td>
                                <td>Somme de expr (nombre)</td>
                            </tr>
                      <tr>
                                <td>VARIANCE([DISTINCT | ALL] expr)</td>
                                <td>Variance de expr (nombre)</td>
                            </tr>
                
                </table>
                
                Utilisées sans GROUP BY, ces fonctions s’appliquent à la totalité ou à une seule partie d’une
table comme le montrent l'exemple suivant :<br>
                <code>SELECT AVG(salary), AVG(commission_pct) FROM employees WHERE salary > 100;//Moyenne des salaires et des commissions des employés dont le salaire es superieur a 100</code><br><br><br>
                Étudions à présent ces fonctions dans le cadre de regroupements de lignes<br><br>
                
                <u>Étude du GROUP BY et HAVING</u><br><br>
                Le groupement de lignes dans une requête se programme au niveau surligné de l’instruction
                SQL suivante :<br>
                SELECT col1[, col2…], fonction1Groupe(…)[,fonction2Groupe(…)…]<br>
                FROM nomTable<br>
                [ WHERE condition ]<br>
                <em >GROUP BY col1[, col2]…)<br>
                [ HAVING condition ]</em><br>
                [ ORDER BY… ] ;<br><br>
                ● la clause WHERE de la requête permet d’exclure des lignes pour chaque groupement, ou de
                rejeter des groupements entiers. Elle s’applique donc à la totalité de la table ;<br>
                ● la clause GROUP BY liste les colonnes du groupement ;<br>
                ● la clause HAVING permet de poser des conditions sur chaque groupement.<br><br>
                
                <mark style="background-color: gainsboro;color: red;">NOTE: Les colonnes présentes dans le SELECT doivent apparaître dans le GROUP BY. Seules des
fonctions ou expressions peuvent exister en plus dans le SELECT.
Les alias de colonnes ne peuvent pas être utilisés dans la clause GROUP BY.</mark><br><br>
                Il est aussi possible de grouper sur plusieurs colonnes (par exemple ici sur les colonnes compa
et typeAvion pour classifier les pilotes selon ces deux critères).<br>
Utilisées avec GROUP BY, les fonctions s’appliquent désormais à chaque regroupement
comme le montrent l'exemple suivant :<br>
                
                
                <code>SELECT manager_id, COUNT(*), COUNT(employee_id) FROM employees GROUP BY manager_id</code><br><br>
                
                <u id="opa">9. LES OPERATEURS ASSEMBLISTES</u><br><br>
                Une des forces du modèle relationnel repose sur le fait qu’il est fondé sur une base mathématique (théorie des ensembles). Le langage SQL programme les opérations binaires (entre deux
tables) suivantes :<br>
● intersection par l’opérateur INTERSECT qui extrait des données présentes simultanément
dans les deux tables ;<br>
● union par les opérateurs UNION et UNION ALL qui fusionnent des données des deux tables ;<br>
● différence par l’opérateur MINUS qui extrait des données présentes dans une table sans
être présentes dans la deuxième table ;<br>
● produit cartésien par le fait de disposer de deux tables dans la clause FROM, ce qui permet
de composer des combinaisons à partir des données des deux tables.<br><br>
                
                Un opérateur ensembliste se place entre deux requêtes comme le montre la syntaxe simplifiée
suivante :<br>
• <code>SELECT … FROM nomTable [WHERE …] opérateur SELECT … FROM nomTable
[WHERE …];</code><br>
Les opérateurs ensemblistes ont pour l’instant tous la même priorité. Cependant, pour être
conformes aux nouvelles directives de la norme, les versions ultérieures d’Oracle privilégieront
l’opérateur INTERSECT par rapport aux autres<br><br>
                Si une requête contient plusieurs de ces opérateurs, ils sont évalués de la gauche vers la droite,
quand aucune parenthèse ne spécifie un autre ordre. Ainsi, les deux écritures suivantes produisent des résultats différents :<br>
<code>SELECT … INTERSECT SELECT … UNION SELECT … MINUS SELECT…<br>
SELECT … INTERSECT SELECT … UNION (SELECT … MINUS SELECT …)</code><br><br>
                
               
                <mark style="background-color: gainsboro;color: red;">Restrictions<br>
Seules des colonnes de même type (CHAR, VARCHAR2, DATE ou NUMBER) doivent être comparées avec des opérateurs ensemblistes.
Il n’est pas possible d’utiliser les opérateurs ensemblistes sur des colonnes BLOB, CLOB, BFILE,
ou LONG. Les collections varrays et nested tables (extensions objets) sont également exclues.</mark><br>
                
                <ol>
                    <li>Opérateur INTERSECT<br>
L’opérateur INTERSECT est commutatif (requête1 INTERSECT requête2 est identique à
requête2 INTERSECT requête1). Cet opérateur élimine les duplicatas entre les deux tables
avant d’opérer l’intersection.<br>
Notez qu’à l’affichage, le nom des colonnes est donné par la première requête. La deuxième
fait apparaître deux colonnes dans le SELECT.</li><br>
                
                    <li>Opérateurs UNION et UNION ALL<br>
Les opérateurs UNION et UNION ALL sont commutatifs. L’opérateur UNION permet d’éviter les
duplicatas (comme DISTINCT ou UNIQUE dans un SELECT). UNION ALL ne les élimine pas.</li><br>

                    <li>Opérateur MINUS<br>
L’opérateur MINUS est le seul opérateur ensembliste qui ne soit pas commutatif. Il élimine les
duplicatas avant d’opérer la soustraction.</li><br>

                    <li>Ordonner les résultats<br>
Le résultat d’une requête contenant des opérateurs ensemblistes est trié par défaut par ordre
croissant sauf avec l’opérateur UNION ALL.<br>La clause ORDER BY n’est utilisable qu’une fois en fin d’une requête incluant des opérateurs
ensemblistes. Cette clause accepte le nom des colonnes de la première requête ou la position
de ces colonnes<br>
                    Il faut affecter des alias aux expressions de la première requête pour pouvoir les utiliser dans le
ORDER BY final.</li><br>
                    
                    <li>Produit cartésien<br>
En mathématiques, le produit cartésien de deux ensembles E et F est l’ensemble des couples
(x, y) où x ∈ E et y ∈ F.<br> En transposant au modèle relationnel, le produit cartésien de deux
tables T1 et T2 est l’ensemble des enregistrements (x, y) où x ∈ T1 et y ∈ T2<br><br>
                    NOTE: Le produit cartésien total entre deux tables T1 et T2 se programme sous SQL en positionnant
les deux tables dans la clause FROM sans ajouter de conditions dans la clause WHERE.
Si les conditions sont de la forme « c1 opérateur c2 » avec c1 ∈ T1 et c2 ∈ T2, on parlera de
jointure.<br>
Si les conditions sont de la forme « c1 opérateur valeur1 » ou « c2 opérateur valeur2 », on
parlera de produit cartésien restreint</li>
                  
                </ol>
                
                <b id="joi"><u>10. JOINTURES</u></b><br>
Les jointures permettent d’extraire des données issues de plusieurs tables. Le processus de
normalisation du modèle relationnel est basé sur la décomposition et a pour conséquence
d’augmenter le nombre de tables d’un schéma. Ainsi, la majorité des requêtes utilisent des
jointures nécessaires pour pouvoir extraire des données de tables distinctes.<br>
                Une jointure met en relation deux tables sur la base d’une clause de jointure (comparaison de
colonnes). Généralement, cette comparaison fait intervenir une clé étrangère d’une table avec
une clé primaire d’une autre table (le modèle relationnel est basé sur les valeurs).<br><br>
                
                Classification: <br>
Une jointure peut s’écrire, dans une requête SQL, de différentes manières :<br>
● « relationnelle » (aussi appelée « SQL89 » pour rappeler la version de la norme SQL) ;<br>
● « SQL2 » (aussi appelée « SQL92 ») ;<br>
● « procédurale » (qui qualifie la structure de la requête) ;<br>
● « mixte » (combinaison des trois approches précédentes).<br>
Nous allons principalement étudier les deux premières écritures qui sont les plus utilisées.<br>
                <ol>
                    <li>
                        Jointure relationnelle<br>
                        La forme la plus courante de la jointure est la jointure dite « relationnelle » (aussi appelée
                        SQL89 [MAR 94]), caractérisée par une seule clause FROM contenant les tables et alias à mettre
                        en jointure deux à deux. La syntaxe générale suivante décrit une jointure relationnelle :<br>
                       <code> SELECT [alias1.]col1, [alias2.]col2…
                        FROM nomTable1 [alias1], nomTable2 [alias2]…
                        WHERE (conditionsDeJointure);</code><br>
                            Cette forme est la plus utilisée car elle est la plus simple à écrire. Un autre avantage de ce type
                            de jointure est qu’elle laisse le soin au SGBD d’établir la meilleure stratégie d’accès (choix du
                            premier index à utiliser, puis du deuxième, etc.) pour optimiser les performances.
                            Afin d’éviter les ambiguïtés concernant le nom des colonnes, on utilise en général des alias de
                            tables pour suffixer les tables dans la clause FROM et préfixer les colonnes dans les clauses
                            SELECT et WHERE.
                    </li>
                    <li>
                    Jointures SQL2<br>
Afin de se rendre conforme à la norme SQL2 Oracle propose aussi des directives qui permettent de programmer d’une manière plus verbale les différents types de jointures :<br>
SELECT [ { DISTINCT | UNIQUE } | ALL ] listeColonnes<br>
FROM nomTable1 [{ INNER | { LEFT | RIGHT | FULL } [OUTER] }]<br>
JOIN nomTable2{ ON condition | USING ( colonne1 [, colonne2]… ) }<br>
| { CROSS JOIN | NATURAL [{ INNER | { LEFT | RIGHT | FULL } [OUTER] }]<br>
JOIN nomTable2 } …<br>
[ WHERE condition ];<br><br>
                        Types de jointures<br>
Bien que dans le vocabulaire courant, on ne parle que de « jointures » en fonction de la nature
de l’opérateur utilisé dans la requête, de la clause de jointure et des tables concernées, on
distingue :<br>
● les jointures internes (inner joins).<br>
● l’équijointure (equi join) est la plus connue, elle utilise l’opérateur d’égalité dans la clause
de jointure. La jointure naturelle est conditionnée en plus par le nom des colonnes. La non
équijointure utilise l’opérateur d’inégalité dans la clause de jointure.<br>
● l’autojointure (self join) est un cas particulier de l’équijointure qui met en œuvre deux fois
la même table (des alias de tables permettront de distinguer les enregistrements entre eux).<br>
● la jointure externe (outer join), la plus compliquée, qui favorise une table (dite « dominante ») par rapport à l’autre (dite « subordonnée »).<br> Les lignes de la table dominante sont
retournées même si elles ne satisfont pas aux conditions de jointure.
Le tableau suivant illustre cette classification sous la forme de quelques conditions appliquées
à notre exemple :
                    
                    
                    
                    
                    </li>
                    <li>Jointures procédurales<br>
                        Les jointures procédurales sont écrites par des requêtes qui contiennent des sous-interrogations (SELECT imbriqué). Chaque clause FROM ne contient qu’une seule table.<br><br>
                        SELECT colonnesTable1<br>
                        FROM nomTable1<br>
                        WHERE colonne(s) | expression(s) { IN | = | opérateur }<br>
                        (SELECT colonne(s)delaTable2 FROM nomTable2<br>
                        WHERE colonne(s) | expression(s) { IN | = | opérateur }<br>
                        (SELECT …)<br>
                        [AND (conditionsTable2)]<br>
                        )<br>
                        [AND (conditionsTable1)];<br><br>
                        Cette forme d’écriture n’est pas la plus utilisée mais elle permet de mieux visualiser certaines
                        jointures. Elle est plus complexe à écrire, car l’ordre d’apparition des tables dans les clauses
                        FROM a son importance.<br><br>
                        Seules les colonnes de la table qui se trouve au niveau du premier SELECT peuvent être extraites.<br><br>
                        La sous-interrogation doit être placée entre parenthèses. Elle ne doit pas comporter de clause
ORDER BY mais peut inclure GROUP BY et HAVING.
Le résultat d’une sous-interrogation est utilisé par la requête de niveau supérieur. Une sous-interrogation est exécutée avant la requête de niveau supérieur.
Une sous-interrogation peut ramener une ou plusieurs lignes. Les opérateurs =, >, &#60;=,&#62;=
permettent d’en extraire une, les opérateurs IN, ANY et ALL permettent d’en ramener
plusieurs.
                    
                    </li>
                    <li>
                        Jointures mixtes<br>
Une jointure mixte combine des clauses de jointures relationnelles, procédurales (avec des
sous-interrogations) ou des clauses de jointures SQL2.
Jointure relationnelle procédurale
La jointure mixte suivante combine une clause de jointure relationnelle (en gras) avec une
jointure procédurale (en surligné) pour programmer la requête R4.<br><br>
<code>SELECT SUM(p1.nbHVol)
FROM Pilote p1, Pilote p2
WHERE p1.chefPil = p2.brevet
AND p2.compa = (SELECT comp FROM Compagnie WHERE nomComp =
'Air France')
;</code><br>
Ce type d’écriture peut être intéressant s’il n’est pas nécessaire d’afficher des colonnes des
tables présentes dans les sous-interrogations ou si l’on désire appliquer des fonctions à des
regroupements.
                    
                    </li>
                </ol>
                
            </dd>
        </dl>
                
                
                
                
            </div>

            <footer class="w3-container w3-green">
              <h5>Note: Attention! Dans la pratique, la présence des réponses après l'execution d'un état ne veut pas forcement dire que le code est juste, donc prener du temps de verifier vos réponses. Pour vous exercer sur les tableaux du compte HR, vous avez à votre disposition une liste d'exercice pouvant vous aider dans la partie exercice du menu.</h5>
            </footer>

        </div>
            
            
            </div>
    </body>
</html>

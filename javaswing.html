<!DOCTYPE html>
<html lang="fr" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>JAVA swing</title>
    <link rel="stylesheet" href="javaswing.css">
    <link rel="stylesheet" href="w3.css">
    <h1>Notes sur Swing</h1>
  </head>
  <body class="w3-sand">
      <ol>
        <li>
          <dl class="">
            <dt>Introduction</dt>
            <dd>Swing regroupe un ensemble de classes permettant la construction d'environnements graphiques √©volu√©s
.
Les composants propos√©s sont ind√©pendants de la machine sur laquelle ils s'ex√©cutent (contrairement
√† AWT) : la performance est moindre, mais l'ind√©pendance plus forte.
Swing s'appuie sur un certain nombre de classes non graphiques de AWT (pour la gestion des √©v√®nements, par exemple),
reprend les fonctionnalit√©s de AWT, red√©nit les composants d'interface compl√®tement en Java, inclut des composants d'interface plus riches (listes, panneau √† onglets, etc.). <br>
 * Points forts : portabilit√© (pur java), comportement standard sur toutes plate-formes, large palette de
composants, look and feel congurable (ind√©pendant de la plate-forme). <br>
 * Points faibles : portabilit√© des applets (composants Swing moins impl√©ment√©s dans les navigateurs),
moins bonne performance</dd>
          </dl>
        </li>
        <li>
            <dl class="">
              <dt>La classe JFrame</dt>
              <dd>Pour construire une interface graphique, on utilisera une fen√™tre (JFrame) et on ajoutera des composants graphiques (conteneurs JPanel et contr√¥les graphiques)
                √† son conteneur principal (on pourra ajouter √©galement une barre de menu dans la zone pr√©vue √† cet effet). <br> <br>
                On pourra utiliser les m√©thodes suivantes : (de la classe JFrame) : <br>
                  <ul>
                    <li>setTitle(une cha√Æne de caract√®res) : <br> pour d√©finir le titre de la fen√™tre</li>
                    <li>etDefaultCloseOperation(JFrame.EXIT_ON_CLOSE): <br>pour d√©finir l'action sur la fermeture de
                        la fen√™tre, ici quitter (exit)</li>
                    <li>setSize(largeur, hauteur) : <br> pour d√©finir la taille de la fen√™tre (pas de gestionnaire de positionnement)</li>
                    <li>setVisible(bool√©en) : <br> pour rendre visible/invisible</li>
                    <li>getContentPane() : <br>envoie une r√©f√©rence vers le conteneur principal associ√© √† la fen√™tre ; c'est un
                    objet de classe Container</li>
                    <li>add() : <br>ajoute un objet graphique au conteneur</li>
                  </ul>
                  Par exemple, pour r√©cup√©rer une r√©f√©rence au conteneur principal : <br>
                  <code>Container c = getContentPane ();</code> <br>

                  Une fois, ces di√©rents composants cr√©√©s, il faut indiquer la fa√ßon dont ils sont dispos√©s √† l'√©cran. La
seule chose que nous aurons besoin de savoir est que l'objet JPanel " contiendra tous les autres objets
graphiques. <br>Nous pouvons r√©cup√©rer le conteneur" de la fen√™tre, c'est-√†-dire la zone graphique associ√©e
√† la fen√™tre dans laquelle nous ajouterons nos di√©rents composants graphiques. Cet objet qui nous servira
de "conteneur"est un objet de la classe Jpanel. <br>
La m√©thode setContentPane de la classe JFrame associe le  "conteneur" (la m√©thode add(\,) r√©alise la
m√™me op√©ration) √† la fen√™tre. <br>La syntaxe est la suivante : <br>
              <code>monJFrame . setContentPane ( monJPanel );</code> <br>
              Ensuite, il sufit simplement d'ajouter des objets (JTextField, JButton, JLabel .....) au "conteneur" gr√¢ce √† la m√©thode add de la classe
JPanel.
              </dd>
            </dl>
        </li>

        <li>
            <dl class="">
              <dt>Utiliser un positionnement dynamique des composants</dt>
              <dd>Comme vous pouvez le constater, les composants graphiques se rajoutent les uns √† la suite des autres
et m√™me si c'est susant pour certaines applications basiques, c'est insusant pour construire de vraies
applications.<br>
Heureusement pour nous, la disposition des objets graphiques dans un JPanel est r√©alis√©e par une
classe particuli√®re d'objets appel√© gestionnaire de positionnement (layout Managers). Ces gestionnaires
de positionnement ont une s√©mantique calqu√©e sur celle qui lie un JPanel √† une fen√™tre JFrame, il faut
associer un gestionnaire de positionnement √† un JPanel.<br>
Nous n'avons heureusement pas √† √©crire un gestionnaire de positionnement (m√™me si cela est possible)
car la biblioth√®que Java fournit d√©j√† un certain nombre de gestionnaires de positionnement qui correspondent aux situations les plus courantes. Voir par exemple la documentation de Java √† cette adresse
http://docs.oracle.com/javase/tutorial/uiswing/layout/using.html.<br>
Sans gestionnaire (pas de layout manager, valeur 'null', d√©conseill√©), le placement des composants est
manuel (c'est ce qui a √©t√© utilis√© dans l'exercice pr√©c√©dent) : <br>
                      <ul>
                        <li>pas de redimensionnement automatique des composants lors d'un redimensionnement de la fen√™tre</li>
                        <li>gestion de la taille manuelle</li>
                        <li>complexit√© du placement (coordonn√©es x,y)</li>
                        <li>complexit√© de la modication de l'interface : si un composant est d√©cal√©, d'autres doivent l'√™tre√©galement</li>
                      </ul>

                    <h3> Les gestionnaires de positionnement</h3>
                      Les gestionnaires de positionnement automatisent le placement dynamique des composants dans un
                      conteneur selon des r√®gles pr√©√©tablies. Les gestionnaires courants sont les suivantes : <br>
                        - FlowLayout : (par d√©faut pour JPanel) : les composants sont plac√©s les uns apr√®s les autres, avec
                      un passage √† la ligne suivante quand une ligne est pleine <br>
                       - BorderLayout : (par d√©faut pour JFrame) : d√©nit 5 zones, avec un composant par zone :
                      1 zone haute (BorderLayout.NORTH) et 1 zone basse (BorderLayout.SOUTH) <br>
                      - au milieu 3 zones : gauche (BorderLayout.WEST), centre (BorderLayout.CENTER, option par
                      d√©faut) et droite (BorderLayout.EAST) <br>
                       - BoxLayout : les composants sont plac√©s les uns au dessous des autres, ou les uns apr√®s les autres <br>
                        - GridLayout : les composants sont plac√©s dans une grille <br>
                       - CardLayout et GridBagLayout sont plus complexes √† manipuler <br>
                      Pour associer un gestionnaire de placement √† un conteneur, on utilise la m√©thode setLayout(objet
                      gestionnaire). <br>
                      Par exemple: <br>
                      <code>JPanel pnl1 = new JPanel (); <br>
                        pnl1 . setLayout ( new BorderLayout ());</code> <br>
                        La conception d'une interface graphique va consister en l'utilisation la plus judicieuse de conteneurs
                        (comme les JPanel) associ√©s aux gestionnaires de placement les plus adapt√©s.


                        <ul>
                          <li>xemple avec FlowLayout <br>
La classe FlowLayout propose 3 constructeurs : <br>
  -  FlowLayout() : les composants sont centr√©s, laisse 5 pixels entre chaque composant <br>
 - FlowLayout(int alignement) : l'alignement des composants est pr√©cis√© <br>
  -  FlowLayout(int alignement, int horz, int vert) : l'alignement des composants est pr√©cis√©, ainsi que
l'espace entre chaque composant, horizontalement et verticalement
avec l'alignement parmi : FlowLayout.LEFT, FlowLayout.CENTER, FlowLayout.RIGHT, FlowLayout.LEADIN
FlowLayout.TRAILING .</li>
                          <li>Exemple avec BoxLayout <br>
La classe GridLayout propose 3 constructeurs : <br>
 - BoxLayout(Container target, int axe) : une simple colonne est cr√©√©e
avec la valeur de axe parmi les constantes : X_AXIS (placement horizontal), Y_AXIS (placement vertical),
etc.</li>
                          <li>Exemple avec GridLayout <br>
Le gestionnaire GridLayout d√©nit une grille d'un certain nombre de lignes et de colonnes, et place un
composant (conteneur ou contr√¥le graphique) par cellule ainsi d√©nie. Il propose 3 constructeurs : <br>
 -  GridLayout() : une simple colonne est cr√©√©e</li> <br>
 - GridLayout(int numRows, int numColumns) : une grille comportant un certain nombre de rang√©es
et de colonnes est d√©nie <br>
 - GridLayout(int numRows, int numColumns, int hGap, int vGap) : une grille comportant un certain nombre de rang√©es et de colonnes est d√©nie, ainsi que l'espace entre chaque composant,
horizontalement et verticalement
                          <li>Exemples avec BorderLayout <br>
Le gestionnaire BorderLayout d√©nit 5 zones et place 1 seul composant (conteneur ou contr√¥le graphique) par zone . <br>
pour ajouter un objet : void add(Component compObj, Object region) <br>
Pour avoir la possibilit√© d'ajouter 2 composants dans un m√™me zone, il va falloir
 - ajouter un conteneur dans la zone : un objet de la classe JPanel (c'est le conteneur le plus utilis√©) <br>
 - pr√©ciser le gestionnaire de positionnement pour ce conteneur : ici BorderLayout
Pour d√©nir le gestionnaire de pr√©sentation BorderLayout(): <br>
<code>setLayout ( new BorderLayout ()); // pas n√©cessaire si d√©j√° d√© fini</code> <br>
Pour ajouter un composant dans l'un des zones d'un conteneur li√© au gestionnaire BorderLayout : <br>
<code>conteneur . add( objet contr √¥le graphique , BorderLayout . NORTH );</code> <br>
Comme dans le cas de l'association d'une fen√™tre √† un JPanel, il est n√©cessaire pour utiliser un gestionnaire de positionnement de : <br>
1. cr√©er un objet gestionnaire de positionnement ; <br>
2. l'associer au JPanel par l'appel √† la m√©thode setLayout de la classe JPanel ; <br>
3. la m√©thode add de JPanel que nous utilisions pour ajouter des objets est surcharg√© et prend un
param√®tre suppl√©mentaire indiquant le positionnement de l'objet en question. <br> <br>
Par exemple, pour cr√©er un BorderLayout et l'associer √† notre JPanel et positionner le bouton en haut
il est n√©cessaire de faire : <br>
<code>
  // cr√© ation d'un objet de type Bouton <br>
JButton monBouton = new JButton (" Java ");<br>
// maintenant on cr√©e et on associe le JPanel √° la fen √™ tre<br>
JPanel panel = new JPanel ();<br>
maFenetre . setContentPane ( panel );<br>
// cr√© ation du BorderLayout et association au Jpanel<br>
BorderLayout monLayout = new BorderLayout ();<br>
panel . setLayout ( monLayout );<br>
// et on rajoute notre boutton<br>
panel .add( monBouton , BorderLayout . NORTH );</code><br>
en n'oubliant pas d'ins√©rer l'importation suivante : import java.awt.BorderLayout;

                          </li>
                          <li></li>
                          <li></li>
                        </ul>
              </dd>
            </dl>
        </li>

        <li>
            <dl class="">
              <dt></dt>
              <dd></dd>
            </dl>
        </li>

        <li>
            <dl class="">
              <dt></dt>
              <dd></dd>
            </dl>
        </li>  <li>
              <dl class="">
                <dt></dt>
                <dd></dd>
              </dl>
          </li>


      </ol>
  </body>
</html>
